# Инструменты разработчика. Вопросы и ответы

## 0. Основные команды оболочки и работа в терминале Linux

### (a) Основные команды

**pwd**
- **Ответ:** Показывает полный путь к текущей рабочей директории

**cd**
- **Ответ:** Изменяет текущую директорию
- `cd ~` - домашняя директория
- `cd ..` - на уровень выше
- `cd -` - предыдущая директория

**ls и её опции -1, -a и -i**
- **Ответ:**
    - `ls -1` - вывод по одному файлу на строку
    - `ls -a` - показать все файлы (включая скрытые)
    - `ls -i` - показать inode файлов
    - `ls -l` - полная информация по файлам: права доступа, тип файла, владалец, группа, размер, дата изменения, имя файла

**echo и её опции -n и -e**
- **Ответ:**
    - `echo -n` - вывод без перевода строки
    - `echo -e` - интерпретация escape-последовательностей (\n, \t)

**printf, спецификаторы %s, %c, %d, %x, %f, %8s, %08d и %.2f**
- **Ответ:**
    - `%s` - строка
    - `%c` - символ
    - `%d` - целое число
    - `%x` - шестнадцатеричное число
    - `%f` - число с плавающей точкой
    - `%8s` - строка шириной 8 символов
    - `%08d` - число с ведущими нулями (8 знаков)
    - `%.2f` - число с 2 знаками после запятой

**cat и её опция -n**
- **Ответ:** `cat -n` показывает содержимое файла с номерами строк

**less и её опции -N и -R. Горячие клавиши**
- **Ответ:**
    - `less -N` - показывать номера строк
    - `less -R` - интерпретировать цветовые коды
    - **Горячие клавиши:**
        - Пробел - следующая страница
        - b - предыдущая страница
        - q - выход
        - g - начало файла
        - G - конец файла
        - n - следующее совпадение при поиске
        - N - предыдущее совпадение

**Текстовый редактор nano**
- **Ответ:** Простой консольный текстовый редактор. Управление через комбинации клавиш (Ctrl+O - сохранить, Ctrl+X - выйти)

**file**
- **Ответ:** Определяет тип файла по его содержимому

**alias, создание и удаление алпасов**
- **Ответ:**
    - `alias ll='ls -la'` - создать алиас
    - `unalias ll` - удалить алиас
    - `alias` - показать все алиасы
    - Для сохранения навсегда добавить в ~/.bashrc

**man, поиск в конкретном разделе**
- **Ответ:** `man 5 passwd` - открыть раздел 5 руководства passwd

**date, печать даты/времени в форматированном виде**
- **Ответ:** `date +"%Y-%m-%d %H:%M:%S"` - вывод в формате "2024-01-15 14:30:25"

### (b) Команды для манипуляции с файлами

**touch**
- **Ответ:** Создает пустой файл или обновляет время модификации существующего

**mkdir и её опция -p**
- **Ответ:** `mkdir -p dir1/dir2/dir3` - создает все промежуточные директории

**cp и её опции -r, -a, -t, -i, -u, -n**
- **Ответ:**
    - `cp -r` - рекурсивное копирование директорий
    - `cp -a` - сохранить атрибуты и рекурсивно копировать
    - `cp -t dir file1 file2` - копировать файлы в указанную директорию
    - `cp -i` - интерактивный режим (спрашивать подтверждение)
    - `cp -u` - копировать только если файл новее
    - `cp -n` - не перезаписывать существующие файлы

**mv, переименование файлов с помощью mv**
- **Ответ:** `mv oldname newname` - переименование файла

**rm и её опции -r, -f**
- **Ответ:**
    - `rm -r` - рекурсивное удаление директорий
    - `rm -f` - принудительное удаление без подтверждения

### (c) Путь к файлу

**Абсолютный и относительный путь**
- **Ответ:**
    - Абсолютный: начинается с / (/home/user/file.txt)
    - Относительный: относительно текущей директории (./file.txt)

**Сокращение имён директорий: . , .. , ~alice**
- **Ответ:**
    - `.` - текущая директория
    - `..` - родительская директория
    - `~alice` - домашняя директория пользователя alice

### (d) Горячие клавиши, используемые в терминале

**Ctrl-C**
- **Ответ:** Прервать выполнение текущей команды

**Ctrl-D**
- **Ответ:** Конец ввода (EOF) или выход из терминала

**Ctrl-Z**
- **Ответ:** Приостановить текущий процесс (отправить в фон)

### (e) Команды для архивации

**gzip и её опции -d и -k**
- **Ответ:**
    - `gzip -d` - распаковать
    - `gzip -k` - сохранить исходный файл

**bzip2 и её опции -d и -k**
- **Ответ:**
    - `bzip2 -d` - распаковать
    - `bzip2 -k` - сохранить исходный файл

**tar и её опции -c, -x, -t, -v, -f, -z и -j**
- **Ответ:**
    - `tar -c` - создать архив
    - `tar -x` - распаковать архив
    - `tar -t` - показать содержимое архива
    - `tar -v` - подробный вывод
    - `tar -f` - указать имя файла архива
    - `tar -z` - работать с gzip
    - `tar -j` - работать с bzip2
    - Пример: `tar -czvf archive.tar.gz dir/`

### (f) Пакетные менеджеры

**Пакетные менеджеры apt и dnf**
- **Ответ:**
    - **apt (Debian/Ubuntu):**
        - `apt install package` - установить пакет
        - `apt remove package` - удалить пакет
        - `apt update` - обновить информацию о пакетах
        - `apt upgrade` - обновить установленные пакеты
        - `apt search pattern` - поиск пакетов

    - **dnf (Fedora/RHEL):**
        - `dnf install package`
        - `dnf remove package`
        - `dnf update`
        - `dnf upgrade`
        - `dnf search pattern`

---

## 1. Основы git

### (a) Системы контроля версий

**Что такое система контроля версий?**
- **Ответ:** Программное обеспечение для отслеживания изменений в файлах и координации работы нескольких людей

**Локальные, централизованные и распределённые системы контроля версий**
- **Ответ:**
    - **Локальные:** версии хранятся на одном компьютере (RCS, SCCS)
    - **Централизованные:** один сервер хранит все версии (SVN, CVS)
    - **Распределённые:** каждый разработчик имеет полную копию репозитория (Git, Mercurial)

**Отличие git от других систем контроля версий**
- **Ответ:**
    - Распределённая архитектура
    - Высокая скорость работы
    - Эффективная работа с ветками
    - Целостность данных (SHA-1 хэши)
    - Поддержка нелинейной разработки

### (b) Настройка git

**Команда git config**
- **Ответ:** `git config --list` - показать все настройки

**Добавление и удаление настроек**
- **Ответ:**
    - `git config --global user.name "Name"` - добавить настройку
    - `git config --global --unset user.name` - удалить настройку

**Уровни настроек: Системный, Глобальный, Локальный**
- **Ответ:**
    - **Системный:** `/etc/gitconfig` - для всех пользователей
    - **Глобальный:** `~/.gitconfig` - для текущего пользователя
    - **Локальный:** `./.git/config` - для конкретного репозитория

**Файлы конфигурации**
- **Ответ:** Указаны выше для каждого уровня

**Основные настройки: user.name, user.email, core.editor, core.autocrlf, alias.<name>**
- **Ответ:**
    - `user.name` - имя пользователя
    - `user.email` - email пользователя
    - `core.editor` - текстовый редактор по умолчанию
    - `core.autocrlf` - обработка переводов строк (Windows/Linux)
    - `alias.co checkout` - создание алиасов

### (c) Создание репозитория

**Команда git init и её опция --bare**
- **Ответ:**
    - `git init` - создать новый репозиторий
    - `git init --bare` - создать "голый" репозиторий (без рабочей директории)

**Команда git clone**
- **Ответ:** `git clone url destination` - клонировать существующий репозиторий

### (d) Работа с файлами и коммитами

**Рабочая директория. Индекс.**
- **Ответ:**
    - **Рабочая директория** - файлы на диске
    - **Индекс (Staging Area)** - подготовленные к коммиту файлы

**Команда git add. Добавление всех изменений из рабочей директории в индекс.**
- **Ответ:** `git add .` - добавить все изменения в индекс

**Удаление файлов из индекса. Команда git rm и её опция --cached.**
- **Ответ:**
    - `git rm --cached file` - удалить файл только из индекса
    - `git rm file` - удалить из индекса и рабочей директории

**Локальный репозиторий. Коммит. Хэш коммита.**
- **Ответ:**
    - **Коммит** - фиксация изменений в репозитории
    - **Хэш коммита** - уникальный идентификатор (SHA-1)

**Команда git commit и её опция -m**
- **Ответ:** `git commit -m "message"` - создать коммит с сообщением

### (e) Команды для просмотра информации индекса и локального репозитория

**git status**
- **Ответ:** Показывает статус рабочей директории и индекса

**git show**
- **Ответ:** Показывает изменения конкретного коммита

**git diff и её опция --staged**
- **Ответ:**
    - `git diff` - различия между рабочей директорией и индексом
    - `git diff --staged` - различия в индексе

**git log и её опции --oneline, --graph, --all, --pretty=format**
- **Ответ:**
    - `git log --oneline` - компактный вывод
    - `git log --graph` - с графиком веток
    - `git log --all` - все ветки
    - `git log --pretty=format:"%h %s"` - пользовательский формат

**git log для поиска в истории, её опции --since, --author, --grep, -S**
- **Ответ:**
    - `git log --since="1 week ago"` - фильтрация по времени
    - `git log --author="name"` - фильтрация по автору
    - `git log --grep="pattern"` - поиск в сообщениях коммитов
    - `git log -S"text"` - поиск по изменениям в коде

**git blame**
- **Ответ:** Показывает автора каждой строки файла

### (f) Работа с ветками

**Что такое ветка?**
- **Ответ:** Указатель на коммит, позволяющий вести независимую разработку

**Основная ветка main**
- **Ответ:** Основная ветка разработки (ранее называлась master)

**Команда git branch и её опции -d, -D, -m, -M, -v, -r, -vv**
- **Ответ:**
    - `git branch` - список веток
    - `git branch -d branch` - удалить ветку (безопасно)
    - `git branch -D branch` - принудительно удалить ветку
    - `git branch -m newname` - переименовать текущую ветку
    - `git branch -v` - показать последний коммит в каждой ветке
    - `git branch -r` - показать удалённые ветки
    - `git branch -vv` - подробная информация о связях с удалёнными ветками

### (g) Адресация коммитов

**Адресация коммитов с использованием хэша**
- **Ответ:** Можно использовать полный (40 символов) или сокращённый (7+ символов) хэш

**Полный и сокращённый хэш коммита**
- **Ответ:**
    - Полный: 40 шестнадцатеричных символов
    - Сокращённый: первые 7+ символов (уникальные в рамках репозитория)

**Адресация коммитов с помощью веток и указателя HEAD**
- **Ответ:**
    - `main` - последний коммит в ветке main
    - `HEAD` - текущий коммит

**Символы ~ и ^**
- **Ответ:**
    - `~` - родительский коммит (`HEAD~1` - предыдущий коммит)
    - `^` - родительский коммит (аналогично `~`)

### (h) Перемещение по графу коммитов

**Указатель HEAD**
- **Ответ:** Указывает на текущий коммит/ветку

**Команда git switch и её опции -c и --detach**
- **Ответ:**
    - `git switch -c newbranch` - создать и переключиться на новую ветку
    - `git switch --detach commit` - переключиться на конкретный коммит

**Чем git switch отличается от старой команды git checkout?**
- **Ответ:** `git switch` более безопасная и понятная команда специально для переключения веток, тогда как `git checkout` имела множество функций

**Переход на отдельный коммит. Состояние detached HEAD.**
- **Ответ:** `git switch --detach commit_hash` - переключение на конкретный коммит

**Чем опасно состояние detached HEAD?**
- **Ответ:** Коммиты, сделанные в этом состоянии, могут быть потеряны при переключении на другую ветку

### (i) Слияние

**Слияние веток. Команда git merge.**
- **Ответ:** `git merge branch` - объединить изменения из указанной ветки в текущую

**Слияние перемоткой (fast-forward merge). Когда используется такой вид слияния?**
- **Ответ:** Используется когда нет расхождений в истории (текущая ветка - прямой предок целевой)

**Опция --no-ff**
- **Ответ:** `git merge --no-ff` - запретить fast-forward, всегда создавать коммит слияния

**Конфликты при слиянии. Когда возникают конфликты?**
- **Ответ:** Возникают при изменении одних и тех же строк в разных ветках

**Как разрешить конфликт?**
- **Ответ:**
    1. Редактировать конфликтующие файлы (убрать маркеры конфликта)
    2. `git add` - пометить файлы как разрешённые
    3. `git merge --continue` - завершить слияние

**Команды git merge --abort, git merge --continue**
- **Ответ:**
    - `git merge --abort` - отменить слияние
    - `git merge --continue` - продолжить после разрешения конфликта

**Как отменить произведённое слияние?**
- **Ответ:** `git reset --hard HEAD~1` (если слияние было последним коммитом)

### (j) Перебазирование

**Перебазирование веток. Команда git rebase.**
- **Ответ:** `git rebase target_branch` - переместить коммиты текущей ветки на целевую

**Отличие перебазирования от слияния**
- **Ответ:** Перебазирование создаёт линейную историю, слияние сохраняет историю веток

**Преимущества и недостатки перебазирования по сравнению со слиянием**
- **Ответ:**
    - **Преимущества:** чистая история, легче читать
    - **Недостатки:** переписывает историю, опасно для опубликованных коммитов

**Конфликты при перебазировании**
- **Ответ:** Аналогичны конфликтам при слиянии

**Как разрешить конфликт, возникший при перебазировании?**
- **Ответ:**
    1. Разрешить конфликт в файлах
    2. `git add` - пометить как разрешённые
    3. `git rebase --continue` - продолжить

**Команды: git rebase --abort, git rebase --continue, git rebase --skip**
- **Ответ:**
    - `--abort` - отменить перебазирование
    - `--continue` - продолжить после разрешения конфликта
    - `--skip` - пропустить текущий коммит

**Как отменить произведённое перебазирование?**
- **Ответ:** Использовать `git reflog` чтобы найти старый HEAD, затем `git reset --hard`

## 2. Продолжение git

### (a) Откат состояния

**Команда git reset и её режимы --soft, --mixed и --hard**
- **Ответ:**
    - `git reset --soft` - отменяет коммит, но сохраняет изменения в индексе
    - `git reset --mixed` (по умолчанию) - отменяет коммит, изменения в рабочей директории
    - `git reset --hard` - полностью отменяет коммит и удаляет изменения

**Как меняется рабочая директория, индекс и локальный репозиторий**
- **Ответ:**
    - **--soft:** репозиторий ← откат, индекс ← изменения остаются, рабочая директория ← без изменений
    - **--mixed:** репозиторий ← откат, индекс ← очищается, рабочая директория ← изменения остаются
    - **--hard:** репозиторий ← откат, индекс ← очищается, рабочая директория ← изменения удаляются

**Как отменить произведённый откат состояния?**
- **Ответ:** Использовать `git reflog` чтобы найти старый коммит, затем `git reset --hard`

**Команда git reflog, что она показывает?**
- **Ответ:** Покажает историю всех перемещений HEAD (включая удалённые коммиты)

**В каких случаях использование git reset может привести к безвозвратной потере данных?**
- **Ответ:** При использовании `git reset --hard` на незакоммиченных изменениях или если не сохранить хэш удалённых коммитов

**Команда git restore и её опция --source**
- **Ответ:** `git restore --source=commit file` - восстановить файл из указанного коммита

**Как восстановить случайно удалённый файл в рабочей директории?**
- **Ответ:** `git restore file` или `git checkout HEAD -- file`

### (b) Копирование отдельных коммитов

**Команда git cherry-pick**
- **Ответ:** `git cherry-pick commit_hash` - применить изменения из конкретного коммита к текущей ветке

**В чём недостатки использования git cherry-pick?**
- **Ответ:** Создаёт дубликаты коммитов, может нарушить историю, сложно отслеживать происхождение изменений

**Конфликты при копировании коммитов**
- **Ответ:** Аналогичны конфликтам при слиянии

**Команды: git cherry-pick --abort, --continue, --skip**
- **Ответ:**
    - `--abort` - отменить операцию
    - `--continue` - продолжить после разрешения конфликта
    - `--skip` - пропустить текущий коммит

### (c) Интерактивное перебазирование

**Команда git rebase -i**
- **Ответ:** `git rebase -i target` - интерактивное перебазирование с редактированием коммитов

**Файл git-rebase-todo**
- **Ответ:** Файл со списком коммитов для перебазирования и командами для каждого

**Команды интерактивного перебазирования: pick, reword, edit, squash, fixup, drop**
- **Ответ:**
    - `pick` - использовать коммит как есть
    - `reword` - использовать коммит, но изменить сообщение
    - `edit` - остановиться для редактирования коммита
    - `squash` - объединить с предыдущим коммитом
    - `fixup` - объединить, но отбросить сообщение
    - `drop` - удалить коммит

**Конфликты при интерактивном перебазировании**
- **Ответ:** Разрешаются аналогично обычному перебазированию

**Как отменить произведённое интерактивное перебазирование?**
- **Ответ:** `git rebase --abort` или через `git reflog`

### (d) Типы файлов в git

**Отслеживаемые (tracked)**
- **Ответ:** Файлы, которые были в каком-либо коммите или добавлены в индекс
    - **Индексированные (staged)** - подготовлены к следующему коммиту
    - **Неизменённые (unmodified)** - без изменений с последнего коммита
    - **Изменённые (modified)** - изменены с последнего коммита

**Неотслеживаемые (untracked)**
- **Ответ:** Файлы, которые никогда не добавлялись в git

**Игнорируемые (ignored)**
- **Ответ:** Файлы, указанные в .gitignore

### (e) Игнорируемые файлы

**Файл .gitignore**
- **Ответ:** Файл с шаблонами файлов/директорий для игнорирования

**Как игнорировать все файлы в репозитории с данным именем**
- **Ответ:** `filename` - игнорировать файлы с таким именем везде

**Как игнорировать все директории в репозитории с данным именем**
- **Ответ:** `dirname/` - игнорировать директории с таким именем

**Как игнорировать один конкретный файл**
- **Ответ:** `/specific/file.txt` - полный путь

**Как игнорировать файлы по шаблону *, ?, [..]**
- **Ответ:**
    - `*.log` - все файлы .log
    - `file?.txt` - file1.txt, fileA.txt и т.д.
    - `file[0-9].txt` - file0.txt, file1.txt, ..., file9.txt

**Как сделать исключение из игнорирования**
- **Ответ:** `!important.log` - не игнорировать important.log

**Игнорирование пустых директорий. Как заставить git не игнорировать пустые директории?**
- **Ответ:** Git не отслеживает пустые директории. Можно создать пустой файл `.gitkeep`

### (f) Очистка репозитория

**На какие типы файлов не действует команда git reset --hard?**
- **Ответ:** На неотслеживаемые файлы

**Какие типы файлов не меняются при использовании git switch?**
- **Ответ:** Неотслеживаемые файлы и изменения в отслеживаемых файлах (если есть конфликты)

**Команда git clean и её опции -f, -d, -x, -X, -n**
- **Ответ:**
    - `git clean -f` - удалить неотслеживаемые файлы
    - `git clean -d` - удалить неотслеживаемые директории
    - `git clean -x` - удалить и игнорируемые файлы
    - `git clean -X` - удалить только игнорируемые файлы
    - `git clean -n` - показать что будет удалено (пробный запуск)

### (g) Удалённый репозиторий

**Удалённый репозиторий. Реморт (remote)**
- **Ответ:**
    - **Удалённый репозиторий** - репозиторий на сервере
    - **Реморт** - ссылка на удалённый репозиторий в локальном репозитории

**В чём разница между удалённым репозиторием и ремортом?**
- **Ответ:** Удалённый репозиторий - это фактический репозиторий, реморт - это его локальное представление

**Команда git remote, её опция -v и подкоманды add, remove, rename, set-url и show**
- **Ответ:**
    - `git remote -v` - показать все реморты с URL
    - `git remote add origin url` - добавить реморт
    - `git remote remove origin` - удалить реморт
    - `git remote rename old new` - переименовать
    - `git remote set-url origin new_url` - изменить URL
    - `git remote show origin` - показать информацию о реморте

### (h) Удалённые ветки

**Что такое удалённая ветка (remote branch)?**
- **Ответ:** Ветка в удалённом репозитории

**Что такое ветка отслеживания (remote-tracking branch)?**
- **Ответ:** Локальная копия удалённой ветки (например, origin/main)

**Какие имена имеют ветки отслеживания в git?**
- **Ответ:** `remotename/branchname` (например, `origin/main`)

**На что указывают такие ветки?**
- **Ответ:** На последнее известное состояние удалённой ветки

**Когда обновляется состояние таких веток?**
- **Ответ:** При выполнении `git fetch` или `git pull`

**Команда: git branch -a**
- **Ответ:** Показать все ветки (локальные и удалённые)

### (i) Работа с удалённым репозиторием

**Команды для взаимодействия: git push, git fetch, git pull**
- **Ответ:**
    - `git push` - отправить изменения на удалённый репозиторий
    - `git fetch` - получить информацию об изменениях
    - `git pull` - получить и объединить изменения

**git push и её опции --all, --tags, -f, --force-with-lease, -u, --set-upstream**
- **Ответ:**
    - `--all` - отправить все ветки
    - `--tags` - отправить все теги
    - `-f` / `--force` - принудительная отправка (опасно!)
    - `--force-with-lease` - безопасный force push
    - `-u` / `--set-upstream` - установить upstream ветку

**git fetch и её опции --prune и --tags**
- **Ответ:**
    - `--prune` - удалить локальные ссылки на удалённые ветки, которых больше нет
    - `--tags` - получить все теги

**git pull и её опции --rebase и --ff-only**
- **Ответ:**
    - `--rebase` - использовать перебазирование вместо слияния
    - `--ff-only` - обновлять только если возможен fast-forward

**Конфликты при использовании git pull**
- **Ответ:** Возникают при несовместимых изменениях в локальной и удалённой ветках

**Чем git pull отличается от git fetch?**
- **Ответ:** `git fetch` только получает информацию, `git pull` также объединяет изменения

**Перезапись истории в удалённом репозитории**
- **Ответ:** Опасная операция, требует `git push -f`

**Отмена изменений в удалённом репозитории**
- **Ответ:** Использовать `git revert` для создания коммита, отменяющего изменения

**Команда git push -f и в чём её опасность?**
- **Ответ:** Перезаписывает историю на удалённом репозитории, может удалить коммиты других разработчиков

**Команда git revert**
- **Ответ:** `git revert commit_hash` - создаёт новый коммит, отменяющий изменения указанного коммита

### (j) Отслеживающие и upstream-ветки

**Что такое отслеживающая ветка (tracking branch)?**
- **Ответ:** Локальная ветка, связанная с удалённой веткой

**Что такое upstream-ветка (upstream-branch)?**
- **Ответ:** Удалённая ветка, связанная с локальной веткой

**Как привязать отслеживающую ветку к upstream-ветке?**
- **Ответ:** `git branch --set-upstream-to=origin/main` или при первом push с `-u`

**Какие преимущества даёт такая привязка?**
- **Ответ:** Упрощает команды push/pull (можно не указывать реморт и ветку)

**Что будет, если не сделать такую привязку?**
- **Ответ:** При push/pull нужно будет всегда указывать реморт и ветку

**Команды: git branch -vv, git branch --set-upstream-to=origin/main, git branch --unset-upstream, git push -u origin main**
- **Ответ:**
    - `git branch -vv` - показать связи с upstream
    - `git branch --set-upstream-to=origin/main` - установить upstream
    - `git branch --unset-upstream` - удалить upstream
    - `git push -u origin main` - отправить и установить upstream

### (k) Тэги

**Чем тэги отличаются от веток?**
- **Ответ:** Тэги - неизменяемые указатели на коммиты, ветки - перемещаемые указатели

**Зачем нужны тэги?**
- **Ответ:** Для отметки релизов, важных версий

**Команда git tag и её опции -d, -l, -a и -m**
- **Ответ:**
    - `git tag v1.0` - создать лёгкий тег
    - `git tag -a v1.0 -m "Version 1.0"` - создать аннотированный тег
    - `git tag -d v1.0` - удалить тег
    - `git tag -l "v1.*"` - список тегов по шаблону

### (l) Pull request

**Веб-сервисы для хранения и работы с удалёнными репозиториями**
- **Ответ:** GitHub, GitLab, Bitbucket, Gitea

**GitHub. GitLab.**
- **Ответ:** Популярные платформы для хостинга git-репозиториев

**Форк.**
- **Ответ:** Копия репозитория в своём аккаунте

**Pull request. Merge request.**
- **Ответ:** Запрос на объединение изменений (в GitHub - Pull Request, в GitLab - Merge Request)

---

## 3. Потоки и конвейеры

### (a) Основные команды, которые часто используются в конвейерах

**tac**
- **Ответ:** Выводит файл в обратном порядке (cat наоборот)

**head и её опции -n и -c**
- **Ответ:**
    - `head -n 10` - первые 10 строк
    - `head -c 100` - первые 100 байт

**tail и её опции -n, -c, -f и -F**
- **Ответ:**
    - `tail -n 10` - последние 10 строк
    - `tail -c 100` - последние 100 байт
    - `tail -f` - следить за изменениями файла
    - `tail -F` - следить за изменениями, переоткрывая файл при ротации

**uniq и её опция -c**
- **Ответ:** `uniq -c` - удалить повторяющиеся строки и показать количество повторений

**sort и её опции -n, -r, -u, -h, -k и -t**
- **Ответ:**
    - `sort -n` - числовая сортировка
    - `sort -r` - обратная сортировка
    - `sort -u` - удалить дубликаты
    - `sort -h` - сортировка человеко-читаемых чисел (2K, 1G)
    - `sort -k 2` - сортировка по второму полю
    - `sort -t ','` - разделитель полей - запятая

**wc и её опции -l, -w, -c и -m**
- **Ответ:**
    - `wc -l` - количество строк
    - `wc -w` - количество слов
    - `wc -c` - количество байт
    - `wc -m` - количество символов

### (b) Потоки и перенаправление

**Стандартные потоки ввода-вывода: stdin, stdout, stderr**
- **Ответ:**
    - **stdin (0)** - стандартный ввод
    - **stdout (1)** - стандартный вывод
    - **stderr (2)** - стандартный вывод ошибок

**Куда эти потоки направлены по умолчанию?**
- **Ответ:** Все направлены в терминал

**Перенаправление потока в файл для перезаписи**
- **Ответ:** `command > file` (stdout), `command 2> file` (stderr)

**Перенаправление потока в файл для дозаписи**
- **Ответ:** `command >> file` (stdout), `command 2>> file` (stderr)

**Перенаправление файла в stdin**
- **Ответ:** `command < file`

**Перенаправление stderr в файл**
- **Ответ:** `command 2> error.log`

**Как перенаправить stdout и stderr в один файл?**
- **Ответ:** `command > file 2>&1` или `command &> file`

**Файл /dev/null**
- **Ответ:** Специальный файл, который отбрасывает все записанные в него данные

**Что произойдёт, если перенаправить потоки stdout/stderr в этот файл?**
- **Ответ:** Вывод будет отброшен (подавлен)

**Что произойдёт, если перенаправить файл /dev/null в stdin?**
- **Ответ:** Команда получит пустой ввод

### (c) Расширения оболочки

**Шаблон поиска (wildcard/glob pattern). Wildcard-символы: *, ?, [!...]**
- **Ответ:**
    - `*` - любое количество любых символов
    - `?` - один любой символ
    - `[abc]` - один из символов a, b, c
    - `[!abc]` - любой символ, кроме a, b, c

**Brace expansion {...}**
- **Ответ:** `file{1,2,3}.txt` → file1.txt file2.txt file3.txt

**Синтаксис подстановки команд $(...)**
- **Ответ:** `echo "Today is $(date)"` - выполнить команду и подставить вывод

**Подстановка процесса <(...) и >(...)**
- **Ответ:**
    - `diff <(ls dir1) <(ls dir2)` - сравнить вывод двух команд
    - `command >(processor)` - перенаправить вывод в процесс

### (d) Конвейеры

**Что такое конвейер оболочки Bash и как его использовать?**
- **Ответ:** `command1 | command2` - вывод command1 становится вводом для command2

**Примеры простых конвейеров**
- **Ответ:** `ls -la | grep ".txt" | wc -l` - посчитать количество .txt файлов

**Код возврата конвейера**
- **Ответ:** Код возврата последней команды в конвейере

**Переменная PIPESTATUS**
- **Ответ:** Массив с кодами возврата всех команд в последнем конвейере

**Как перенаправить поток stderr в конвейер?**
- **Ответ:** `command 2>&1 | next_command`

### (e) Команда find

**Опции команды find: -type, -and, -or, -not, -name/-iname, -maxdepth, -size, -print0, -mtime, -exec**
- **Ответ:**
    - `-type f` - только файлы
    - `-type d` - только директории
    - `-name "*.txt"` - по имени (регистрозависимо)
    - `-iname "*.txt"` - по имени (регистронезависимо)
    - `-maxdepth 2` - максимальная глубина поиска
    - `-size +1M` - размер больше 1 МБ
    - `-mtime -7` - изменены за последние 7 дней
    - `-print0` - вывод с нулевым разделителем (для xargs -0)
    - `-exec command {} \;` - выполнить команду для каждого найденного файла

**Два вида синтаксиса find -exec: с \; и с +**
- **Ответ:**
    - `find . -exec command {} \;` - выполнить команду для каждого файла отдельно
    - `find . -exec command {} +` - выполнить команду один раз для всех файлов

**Чем различаются эти два вида синтаксиса?**
- **Ответ:** С `\;` команда выполняется для каждого файла, с `+` все файлы передаются одной командой

### (f) Команда xargs

**Что делает команда xargs?**
- **Ответ:** Преобразует входной поток в аргументы командной строки

**В каких ситуациях эта команда используется чаще всего?**
- **Ответ:** В комбинации с find для обработки большого количества файлов

**Опции -0, -I и -P**
- **Ответ:**
    - `-0` - нулевой разделитель (для find -print0)
    - `-I {}` - замена строки
    - `-P 4` - параллельное выполнение (4 процесса)

**Преимущества xargs перед find -exec**
- **Ответ:** Может объединять аргументы, поддерживает параллельное выполнение

### (g) Команда tee

**Примеры использования команды tee**
- **Ответ:** `command | tee file.log` - выводит и в файл, и в консоль

**Опция -a**
- **Ответ:** `tee -a` - дописывать в файл, а не перезаписывать

**Использование echo, sudo и tee для записи в файл с правами root**
- **Ответ:** `echo "text" | sudo tee /root/file.txt`

### (h) Команда grep

**Синтаксис команды grep**
- **Ответ:** `grep pattern file`

**Опции: -i, -c, -r, -o, -n, -v, -E, -l, --color=auto, -q, -A, -B, -C**
- **Ответ:**
    - `-i` - игнорировать регистр
    - `-c` - подсчитать количество совпадений
    - `-r` - рекурсивный поиск
    - `-o` - выводить только совпавшую часть
    - `-n` - показывать номера строк
    - `-v` - инвертировать поиск (строки без совпадения)
    - `-E` - расширенные регулярные выражения
    - `-l` - показывать только имена файлов с совпадениями
    - `--color=auto` - подсветка совпадений
    - `-q` - тихий режим (только код возврата)
    - `-A 3` - показать 3 строки после совпадения
    - `-B 3` - показать 3 строки перед совпадением
    - `-C 3` - показать 3 строки до и после

**Примеры использования grep:**
- **Поиск строк, содержащих подстроку, в одном файле:** `grep "text" file.txt`
- **Поиск строк, содержащих подстроку, рекурсивно во всех файлах директории:** `grep -r "text" .`
- **Поиск файлов, содержащих подстроку:** `grep -rl "text" .`
- **Фильтрация вывода команды:** `ls -la | grep ".txt"`
- **Поиск по регулярному выражению:** `grep -E "^[0-9]+" file.txt`

### (i) Регулярные выражения в grep

**Два типа регулярных выражений: BRE и ERE**
- **Ответ:**
    - **BRE** (Basic Regular Expressions) - базовый синтаксис
    - **ERE** (Extended Regular Expressions) - расширенный синтаксис (`grep -E`)

**Основные элементы регулярных выражений ERE:**
- **Обычные символы** - совпадают с самими собой
- **Точка .** - любой один символ
- **Символьные классы […]** - один символ из набора
- **Группировка (…)** - группировка выражений
- **Альтернация |** - или
- **Квантификаторы:**
    - `*` - 0 или более
    - `+` - 1 или более
    - `?` - 0 или 1
    - `{n}` - ровно n раз
    - `{n,}` - n или более
    - `{n,m}` - от n до m раз
- **Якоря строки: ^ и $**
    - `^` - начало строки
    - `$` - конец строки

**Предопределённые классы:**
- `[[:alpha:]]` - буквы
- `[[:digit:]]` - цифры
- `[[:alnum:]]` - буквы и цифры
- `[[:space:]]` - пробельные символы
- `[[:lower:]]` - строчные буквы
- `[[:upper:]]` - прописные буквы
- `[[:punct:]]` - знаки пунктуации
- `[[:xdigit:]]` - шестнадцатеричные цифры

## 5. Пользователи и права доступа Linux

### (a) Пользователи

**UID**
- **Ответ:** User ID - уникальный числовой идентификатор пользователя

**Суперпользователь root**
- **Ответ:** Пользователь с UID 0, имеет полный доступ к системе

**Системные пользователи. Зачем нужны системные пользователи?**
- **Ответ:** Для запуска системных служб и демонов, из соображений безопасности

**Диапазон UID для системных и обычных пользователей**
- **Ответ:**
    - Системные: 0-999 (в некоторых системах 0-499)
    - Обычные: 1000+ (в некоторых системах 500+)

### (b) Группы пользователей

**Группы**
- **Ответ:** Коллекции пользователей для упрощения управления правами

**Основная группа пользователя**
- **Ответ:** Группа, которая назначается пользователю при создании

**Дополнительные группы**
- **Ответ:** Дополнительные группы, в которые входит пользователь

**GID**
- **Ответ:** Group ID - уникальный числовой идентификатор группы

**Команда id и её опция -u**
- **Ответ:** `id -u` - показать UID текущего пользователя

**Команда groups**
- **Ответ:** Показать группы, в которых состоит текущий пользователь

### (c) Домашняя директория

**Стандартное расположение домашней директории**
- **Ответ:** `/home/username/` для обычных пользователей, `/root/` для root

**Что обычно хранится в домашней директории?**
- **Ответ:** Персональные файлы, настройки приложений, рабочие документы

**Файлы ~/.bash_profile и ~/.bashrc**
- **Ответ:**
    - `~/.bash_profile` - выполняется при логине
    - `~/.bashrc` - выполняется при запуске новой оболочки

**Директория /etc/skel**
- **Ответ:** Содержит шаблоны файлов, которые копируются в домашнюю директорию нового пользователя

### (d) Системные файлы, хранящие информацию о пользователях и группах

**/etc/passwd**
- **Ответ:** Содержит информацию о пользователях в формате: `username:password:UID:GID:GECOS:homedir:shell`

**/etc/shadow**
- **Ответ:** Содержит зашифрованные пароли и информацию о сроке действия

**/etc/group**
- **Ответ:** Содержит информацию о группах в формате: `groupname:password:GID:users_list`

**/etc/gshadow**
- **Ответ:** Содержит зашифрованные пароли групп

**Как хранится информация о паролях пользователей?**
- **Ответ:** В `/etc/shadow` в зашифрованном виде (хэш)

**Как хранится принадлежность пользователя к основной группе?**
- **Ответ:** В `/etc/passwd` в поле GID

**Как хранится принадлежность пользователя к дополнительным группам?**
- **Ответ:** В `/etc/group` в поле users_list

**Как отличить обычного пользователя от системного по файлу passwd?**
- **Ответ:** По UID: системные обычно < 1000, обычные ≥ 1000

**Что такое /sbin/nologin?**
- **Ответ:** Оболочка, которая запрещает пользователю вход в систему

**Как понять, что пользователь заблокирован по файлу /etc/shadow?**
- **Ответ:** Пароль начинается с `!` или `*`, или поле пароля пустое

### (e) Работа с пользователями и группами

**useradd и её опции -m, -d, -s и -G**
- **Ответ:**
    - `-m` - создать домашнюю директорию
    - `-d` - указать домашнюю директорию
    - `-s` - указать оболочку
    - `-G` - указать дополнительные группы

**usermod и её опции -G, -aG, -d, -s, -L и -U**
- **Ответ:**
    - `-G` - установить список дополнительных групп
    - `-aG` - добавить к существующим группам
    - `-d` - изменить домашнюю директорию
    - `-s` - изменить оболочку
    - `-L` - заблокировать пользователя
    - `-U` - разблокировать пользователя

**userdel и её опция -r**
- **Ответ:** `userdel -r` - удалить пользователя и его домашнюю директорию

**groupadd и её опция -r**
- **Ответ:** `groupadd -r` - создать системную группу

**groupmod**
- **Ответ:** Изменить параметры группы

**groupdel**
- **Ответ:** Удалить группу

**Создание/удаление основной группы при создании/удалении пользователя**
- **Ответ:** Основная группа создаётся автоматически при создании пользователя

**Использование usermod для блокировки/разблокировки пользователя**
- **Ответ:** `usermod -L username` - заблокировать, `usermod -U username` - разблокировать

### (f) Работа с паролями

**Использование passwd для смены собственного пароля**
- **Ответ:** `passwd` - сменить пароль текущего пользователя

**Использование passwd для смены пароля другого пользователя**
- **Ответ:** `passwd username` - сменить пароль другого пользователя (требуются права root)

### (g) su и sudo

**Переключение на другого пользователя. Команда su.**
- **Ответ:** `su username` - переключиться на другого пользователя

**Полное и неполное переключение**
- **Ответ:**
    - Полное: `su - username` - загрузить окружение пользователя
    - Неполное: `su username` - сохранить текущее окружение

**Выполнение команды от имени другого пользователя. Команда sudo.**
- **Ответ:** `sudo -u username command` - выполнить команду от имени другого пользователя

**Опции sudo -u и -i**
- **Ответ:**
    - `-u username` - выполнить от имени указанного пользователя
    - `-i` - запустить оболочку входа (аналогично `su -`)

**Какой пароль требуется для su и sudo?**
- **Ответ:**
    - `su` - пароль целевого пользователя
    - `sudo` - пароль текущего пользователя

**Различия способов переключения на root: su, su -, sudo -i**
- **Ответ:**
    - `su` - неполное переключение
    - `su -` - полное переключение с загрузкой окружения root
    - `sudo -i` - полное переключение через sudo

**Файл /etc/sudoers. Формат записей.**
- **Ответ:** `username ALL=(ALL) ALL` - пользователь может выполнять любые команды от любого пользователя

**Группа sudo/wheel**
- **Ответ:** Группа пользователей, которым разрешено использовать sudo

**Опасность редактирования /etc/sudoers. Как безопасно редактировать?**
- **Ответ:** Использовать `visudo` - проверяет синтаксис перед сохранением

### (h) Права доступа

**Владелец файла. Группа-владелец.**
- **Ответ:** Пользователь и группа, которым принадлежит файл

**Может ли владелец файла не входить в группу-владелец?**
- **Ответ:** Да, это возможно

**Просмотр прав доступа с помощью ls**
- **Ответ:** `ls -l` показывает права в формате `-rwxr-xr--`

**Символьное и числовое представление прав доступа**
- **Ответ:**
    - Символьное: `rwxr-xr--`
    - Числовое (octal): 754

**Конвертация представлений**
- **Ответ:**
    - r=4, w=2, x=1
    - `rwxr-xr--` = 4+2+1, 4+0+1, 4+0+0 = 754

**chmod и её опция -R**
- **Ответ:**
    - Символьное: `chmod u+x file`
    - Числовое: `chmod 755 file`
    - `-R` - рекурсивно

**Кто может изменять права доступа?**
- **Ответ:** Владелец файла или root

**chown и её опция -R**
- **Ответ:** `chown user:group file` - изменить владельца и группу

**Как изменить группу владельца с помощью chown?**
- **Ответ:** `chown :group file` или `chown user:group file`

**Кто может изменять владельца файла?**
- **Ответ:** Только root

**chgrp и её опция -R**
- **Ответ:** `chgrp group file` - изменить группу-владельца

**Кто может изменять группу владельца файла?**
- **Ответ:** Владелец файла (если он входит в целевую группу) или root

**newgrp**
- **Ответ:** Временно сменить основную группу текущей сессии

**Права r, w, x для обычных файлов**
- **Ответ:**
    - r - чтение файла
    - w - запись в файл
    - x - выполнение файла

**Права r, w, x для директорий**
- **Ответ:**
    - r - чтение списка файлов
    - w - создание/удаление файлов
    - x - доступ к файлам в директории

**Права символических ссылок**
- **Ответ:** Права ссылок всегда `rwxrwxrwx`, реальные права определяются целевым файлом

### (i) Маска

**Права только что созданного файла**
- **Ответ:** 666 & ~umask (обычно 644)

**Права копии файла**
- **Ответ:** Сохраняются права исходного файла

**Команда umask**
- **Ответ:** Показывает или устанавливает маску прав для новых файлов

### (j) SUID, SGID и Sticky Bit

**SUID (Set User ID)**
- **Ответ:** Файл выполняется с правами владельца, а не запустившего пользователя

**Примеры системных файлов с SUID**
- **Ответ:** `passwd`, `sudo`, `ping`

**Работает ли SUID на скриптах?**
- **Ответ:** В большинстве систем Linux - нет, из соображений безопасности

**SGID (Set Group ID)**
- **Ответ:**
    - Для файлов: выполняется с правами группы-владельца
    - Для директорий: новые файлы наследуют группу-владельца директории

**Sticky Bit**
- **Ответ:** В директории пользователи могут удалять только свои файлы

**Пример системной директории с Sticky Bit**
- **Ответ:** `/tmp`

**Символьное и числовое представление**
- **Ответ:**
    - Символьное: SUID=s, SGID=s, Sticky=t
    - Числовое: SUID=4000, SGID=2000, Sticky=1000

---

## 6. Диски и файловые системы

### (a) Единицы измерения объёма информации

**Десятичные и двоичные единицы**
- **Ответ:**
    - Десятичные: KB=1000, MB=1000000, GB=1000000000
    - Двоичные: KiB=1024, MiB=1048576, GiB=1073741824

### (b) Метаданные файлов

**Что включают метаданные файла?**
- **Ответ:** Размер, права доступа, владелец, временные метки, inode

**Где хранятся метаданные?**
- **Ответ:** В таблице inode файловой системы

**Просмотр метаданных с помощью ls -l**
- **Ответ:** Показывает основные метаданные

**Команда stat и её опция -c**
- **Ответ:** `stat -c "format" file` - форматированный вывод метаданных

**Плейсхолдеры для stat -c:**
- **%n** - имя файла
- **%s** - размер в байтах
- **%u/%U** - UID/имя пользователя
- **%g/%G** - GID/имя группы
- **%a/%A** - права доступа (числовые/символьные)
- **%i** - номер inode
- **%F** - тип файла
- **%x/%y/%z** - время доступа/модификации/изменения статуса

**Временные метки atime, mtime, ctime**
- **Ответ:**
    - atime - время последнего доступа
    - mtime - время последней модификации содержимого
    - ctime - время последнего изменения статуса (метаданных)

**Изменение временных меток с помощью touch**
- **Ответ:**
    - `touch -a` - изменить atime
    - `touch -m` - изменить mtime
    - `touch -d` - указать конкретное время

### (c) Типы файлов

**Обычный файл, Директория, Символическая ссылка, Блочное устройство, Символьное устройство**
- **Ответ:** Основные типы файлов в Linux

**Как узнать тип файла:**
- **ls:** `ls -l` показывает тип первым символом (`-` файл, `d` директория, `l` ссылка)
- **stat:** `stat -c %F file`
- **file:** `file filename`

### (d) Файлы устройств

**Директория /dev/**
- **Ответ:** Содержит файлы устройств

**Файлы устройств как интерфейсы**
- **Ответ:** Предоставляют интерфейс для взаимодействия с устройствами

**Major и minor number**
- **Ответ:**
    - Major - идентификатор драйвера устройства
    - Minor - идентификатор конкретного устройства

#### (i) Файлы символьных устройств

**Примеры символьных устройств**
- **Ответ:** Клавиатура, мышь, терминал

**Как передают данные символьные устройства?**
- **Ответ:** По одному символу за раз

**Символьные псевдоустройства: /dev/null, /dev/zero, /dev/random**
- **Ответ:**
    - `/dev/null` - "чёрная дыра"
    - `/dev/zero` - источник нулевых байтов
    - `/dev/random` - генератор случайных чисел

#### (ii) Файлы блочных устройств

**Примеры блочных устройств**
- **Ответ:** Жёсткие диски, SSD, USB-флешки

**Как передают данные блочные устройства?**
- **Ответ:** Блоками фиксированного размера

**Размер блока блочных устройств**
- **Ответ:** Обычно 512 байт или 4 КБ

**Физический и логический размеры блоков**
- **Ответ:**
    - Физический - реальный размер сектора на диске
    - Логический - размер, с которым работает ОС

### (e) Разделы

**Зачем нужны разделы?**
- **Ответ:** Для разделения диска на логические части, изоляции данных, использования разных ФС

**Блочные файлы разделов**
- **Ответ:** `/dev/sda1`, `/dev/sda2` и т.д.

**Команда lsblk**
- **Ответ:** Показать информацию о блочных устройствах и разделах

#### (i) Таблица разделов MBR

**Расположение и размер MBR**
- **Ответ:** Первые 512 байт диска

**Что содержится в MBR?**
- **Ответ:** Код загрузчика, таблица разделов, сигнатура

**Ограничения MBR**
- **Ответ:** Максимум 4 первичных раздела, до 2 ТБ на раздел

**Типы разделов: primary, extended, logical**
- **Ответ:**
    - Primary - основные разделы (до 4)
    - Extended - контейнер для логических разделов
    - Logical - разделы внутри extended

#### (ii) Таблица разделов GPT

**Расположение и размер GPT**
- **Ответ:** В начале и в конце диска, занимает больше места

**Что содержится в GPT?**
- **Ответ:** Заголовок GPT, таблица разделов, backup копия

**Ограничения GPT**
- **Ответ:** До 128 разделов (в Linux больше), разделы до 8 ЗБ

**Команда parted -l**
- **Ответ:** Показать информацию о разделах

**Как узнать тип таблицы разделов?**
- **Ответ:** `parted -l` или `fdisk -l`

### (f) Создание разделов с помощью parted

**Команды parted: print, mklabel, mkpart, rm, resizepart, unit**
- **Ответ:**
    - `print` - показать информацию
    - `mklabel` - создать таблицу разделов
    - `mkpart` - создать раздел
    - `rm` - удалить раздел
    - `resizepart` - изменить размер раздела
    - `unit` - установить единицы измерения

**Скриптовый и тихий режим parted**
- **Ответ:**
    - Скриптовый: `parted -s device command`
    - Тихий: `parted -s -- device command`

### (g) Файловые системы

**Что такое файловая система?**
- **Ответ:** Способ организации и хранения файлов на носителе

**UUID файловой системы**
- **Ответ:** Уникальный идентификатор файловой системы

**Создание файловой системы на разделе**
- **Ответ:** `mkfs -t ext4 /dev/sda1`

**Команда mkfs**
- **Ответ:** `mkfs -t fstype device`

**Команды для отображения информации: lsblk -f, blkid, df, du**
- **Ответ:**
    - `lsblk -f` - информация о ФС
    - `blkid` - UUID и тип ФС
    - `df -hT` - информация о смонтированных ФС
    - `du -hs` - размер директорий

### (h) Монтирование файловой системы

**Что такое монтирование?**
- **Ответ:** Подключение файловой системы к дереву каталогов

**Точка монтирования**
- **Ответ:** Директория, через которую доступна файловая система

**Команда mount и её опция -o**
- **Ответ:** `mount -o options device mountpoint`

**Команда umount**
- **Ответ:** `umount mountpoint` - размонтировать ФС

**Опции монтирования: defaults, rw, ro, noexec, nosuid, noatime**
- **Ответ:**
    - `defaults` - стандартные опции
    - `rw`/`ro` - чтение-запись/только чтение
    - `noexec` - запрет выполнения
    - `nosuid` - игнорирование SUID/SGID
    - `noatime` - не обновлять atime

**Автоматическое монтирование. Файл /etc/fstab.**
- **Ответ:** Содержит информацию о ФС для автоматического монтирования

**Поля в /etc/fstab: file system, mount point, type, options, dump, pass**
- **Ответ:**
    - file system - устройство или UUID
    - mount point - точка монтирования
    - type - тип ФС
    - options - опции монтирования
    - dump - флаг для backup
    - pass - порядок проверки ФС

**Команда mount -a**
- **Ответ:** Монтировать все ФС из /etc/fstab

**Команда findmnt**
- **Ответ:** Показать смонтированные файловые системы

### (i) Команда dd

**Варианты использования dd:**
- **Создание файлов:** `dd if=/dev/zero of=file bs=1M count=10`
- **Копирование файлов:** `dd if=source of=target`
- **Просмотр байт:** `dd if=file bs=1 count=100`
- **Копирование разделов:** `dd if=/dev/sda1 of=/dev/sdb1`
- **Создание образа:** `dd if=/dev/sda of=disk.img`
- **Восстановление из образа:** `dd if=disk.img of=/dev/sda`
- **Запись ISO на флешку:** `dd if=image.iso of=/dev/sdb`

**Опции dd: if, of, bs, count, skip, seek, conv=noerror, conv=sync, conv=notrunc**
- **Ответ:**
    - `if` - входной файл
    - `of` - выходной файл
    - `bs` - размер блока
    - `count` - количество блоков
    - `skip` - пропустить блоки во входном файле
    - `seek` - пропустить блоки в выходном файле
    - `conv=noerror` - продолжать при ошибках
    - `conv=sync` - дополнять неполные блоки
    - `conv=notrunc` - не обрезать выходной файл

**Размер блока (bs) в dd**
- **Ответ:** Влияет на производительность. По умолчанию 512 байт.

### (j) Жёсткие ссылки

**Что такое жёсткая ссылка?**
- **Ответ:** Дополнительное имя для того же inode (файла)

**Команда ln**
- **Ответ:** `ln target linkname` - создать жёсткую ссылку

**Что происходит при создании жёсткой ссылки?**
- **Ответ:** Создаётся новое имя для существующего inode, счётчик ссылок увеличивается

**Равноправность жёстких ссылок**
- **Ответ:** Все жёсткие ссылки равноправны, нет "оригинала"

**Счётчик жёстких ссылок в inode**
- **Ответ:** Показывает количество имён файла

**Что будет при удалении исходного файла?**
- **Ответ:** Файл останется доступен по другим жёстким ссылкам

**Жёсткие ссылки на директории**
- **Ответ:** Обычно запрещены, кроме `.` и `..`

**Можно ли создать жёсткую ссылку между разными ФС?**
- **Ответ:** Нет, жёсткие ссылки работают только в пределах одной ФС

### (k) Символические (мягкие) ссылки

**Что такое символическая ссылка?**
- **Ответ:** Файл, содержащий путь к целевому файлу

**Команда ln -s**
- **Ответ:** `ln -s target linkname` - создать символическую ссылку

**Как узнать куда указывает ссылка?**
- **Ответ:** `readlink linkname` или `ls -l`

**Что будет при удалении исходного файла?**
- **Ответ:** Ссылка станет "битой" (dangling)

**Можно ли создать символическую ссылку на директорию?**
- **Ответ:** Да

**Можно ли создать символическую ссылку между разными ФС?**
- **Ответ:** Да

**Работа команд с символическими ссылками:**
- **cp:** Копирует файл (не ссылку), `cp -a` сохраняет ссылки
- **chmod:** Применяется к целевому файлу
- **rm:** Удаляет саму ссылку
- **find:** Не переходит по ссылкам по умолчанию, `-L` включает переход

### (l) Строение файловой системы ext4

**Блоки**
- **Ответ:** Основные единицы хранения данных

**Суперблок**
- **Ответ:** Содержит информацию о ФС (размер, количество inode и т.д.)

**Группы блоков**
- **Ответ:** Логическое разделение ФС для повышения производительности

**Таблица inode**
- **Ответ:** Содержит метаданные всех файлов

**Что хранится в inode файлов разных типов?**
- **Ответ:** Метаданные + для обычных файлов - указатели на блоки данных

**Переполнение таблицы inode**
- **Ответ:** Ошибка "No space left on device" даже при свободном месте

**Журналирование**
- **Ответ:** Запись изменений в журнал перед применением для сохранности данных

### (m) Распространённые файловые системы

**ext4, xfs, FAT, NTFS**
- **Ответ:**
    - **ext4** - стандартная для Linux, журналируемая
    - **xfs** - высокопроизводительная, для больших файлов
    - **FAT** - простая, для флешек
    - **NTFS** - Windows, хорошая надёжность

**Виртуальные файловые системы**
- **Ответ:** procfs, sysfs, tmpfs - ФС в оперативной памяти

---

## 7. Язык Bash

### (a) Интерпретатор Bash

**Терминал**
- **Ответ:** Программа для ввода команд (GNOME Terminal, Konsole и т.д.)

**Оболочка**
- **Ответ:** Интерпретатор команд (Bash, Zsh, Fish)

**Оболочки sh и bash**
- **Ответ:** sh - стандартная оболочка, bash - расширенная версия

**Скрипты Bash. Шебанг.**
- **Ответ:** `#!/bin/bash` - первая строка скрипта, указывает интерпретатор

### (b) Переменные Bash

**Создание и использование переменных**
- **Ответ:** `var=value`, `echo $var`

**Команда unset**
- **Ответ:** `unset var` - удалить переменную

**Переменные среды**
- **Ответ:** Глобальные переменные, доступные всем процессам

**Команда export**
- **Ответ:** `export VAR=value` - сделать переменную средой

**Команда source**
- **Ответ:** `source script.sh` - выполнить скрипт в текущей оболочке

**Как задать переменную среды для одной команды?**
- **Ответ:** `VAR=value command`

**Как создать свою переменную среды?**
- **Ответ:** Добавить `export VAR=value` в `~/.bashrc`

### (c) Команды оболочки

**Внутренние и внешние команды**
- **Ответ:**
    - Внутренние - встроенные в оболочку (cd, echo)
    - Внешние - отдельные исполняемые файлы

**Команда type -a**
- **Ответ:** `type -a command` - показать информацию о команде

**Команда which**
- **Ответ:** `which command` - показать путь к команде

**Переменная среды PATH**
- **Ответ:** Список директорий для поиска команд

**Как создать свою команду?**
- **Ответ:** Создать исполняемый файл в директории из PATH

### (d) Кавычки

**Разница между одинарными и двойными кавычками**
- **Ответ:**
    - Одинарные: никаких подстановок
    - Двойные: работают переменные и некоторые спецсимволы

### (e) Аргументы

**Аргументы командной строки**
- **Ответ:** Параметры, передаваемые скрипту при запуске

**Переменные: $1, $2, $0, $*, $@**
- **Ответ:**
    - `$1, $2, ...` - аргументы
    - `$0` - имя скрипта
    - `$*` - все аргументы как одна строка
    - `$@` - все аргументы как отдельные строки

**Разница "$*" и "$@"**
- **Ответ:** `"$*"` - одна строка, `"$@"` - массив строк

**Проход по аргументам в цикле**
- **Ответ:** `for arg in "$@"; do ... done`

**Команда shift**
- **Ответ:** `shift` - сдвинуть аргументы ($2 становится $1 и т.д.)

### (f) Коды возврата

**Код возврата при успешном завершении**
- **Ответ:** 0

**Как получить код возврата последней команды?**
- **Ответ:** `$?`

**Коды возврата скобочных команд**
- **Ответ:** `(command)` - выполняется в подоболочке

**Команды true и false**
- **Ответ:** `true` возвращает 0, `false` возвращает 1

### (g) Условия if

**Сравнение строк:** `=`, `!=`, `-z`, `-n`
**Сравнение чисел:** `-eq`, `-ne`, `-lt`, `-le`, `-gt`, `-ge`

**Операции проверки:**
- `-n` - строка не пустая
- `-z` - строка пустая
- `-e` - файл существует
- `-f` - обычный файл
- `-d` - директория
- `-r` - доступен для чтения
- `-w` - доступен для записи
- `-x` - доступен для выполнения
- `-v` - переменная определена

**Разница между [[ ... ]] и [ ... ]**
- **Ответ:** `[[ ... ]]` - более мощный синтаксис, поддерживает `&&`, `||`, `=~`

**Проверка на совпадение с регулярным выражением =~**
- **Ответ:** `[[ $string =~ pattern ]]`

**Использование && и || вместо if**
- **Ответ:** `command1 && command2` - выполнить command2 если command1 успешен

### (h) Группировка команд и подоболочки

**Группировка:** `{ command1; command2; }`
**Подоболочка:** `(command1; command2)`

# Ответы на вопросы (подробно, начиная с 7i)

Ниже приведены **вопросы и подробные ответы**, оформленные в стиле вашего примера.

---

## ### (i) Конструкция `case ... esac`

**Вопрос:** *Что такое конструкция `case` в Bash, для чего она нужна и как работает?*

**Ответ:**  
Конструкция `case` — это аналог оператора `switch` из других языков. Она позволяет сравнивать одну переменную со множеством шаблонов (glob-паттернов), выполняя соответствующий блок кода.

Синтаксис:

```bash
case <выражение> in
  шаблон1)
      команды
      ;;
  шаблон2|шаблон3)
      команды
      ;;
  *)
      команды по умолчанию
      ;;
esac
```

**Особенности:**
- Используются **glob-шаблоны** (`*`, `?`, `[abc]`), а не регулярные выражения.
- Можно указывать несколько шаблонов через `|`.
- Завершение блока — двойной `;;`.
- Работает быстрее, чем серия `if [[ ... ]]`.

**Пример:**
```bash
read -p "Введите ответ: " ans
case "$ans" in
  yes|y|Y) echo "Вы ответили ДА" ;;
  no|n|N) echo "Вы ответили НЕТ" ;;
  *) echo "Неизвестный вариант" ;;
esac
```

---

## ### (j) Циклы Bash

### **Вопрос:** *Какие существуют циклы в Bash?*

**Ответ:**  
В Bash есть два основных типа циклов:

---

### **1. Цикл `while`**

Выполняется, пока условие истинно.

```bash
count=0
while [[ $count -lt 3 ]]; do
  echo "count = $count"
  ((count++))
done
```

---

### **2. Цикл `for`**

Используется для перебора значений.

#### Примеры:

**Перебор фиксированного набора:**
```bash
for x in a b c; do
  echo "$x"
done
```

**Итерация по файлам текущей директории:**
```bash
for file in *; do
  echo "$file"
done
```

---

### **IFS**

`IFS` — разделитель слов (по умолчанию пробел, таб, перевод строки).

Если его изменить:

```bash
IFS=:
for x in $PATH; do
  echo "$x"
done
```

---

### **Перенаправление вывода цикла**

```bash
while read line; do
  echo "Строка: $line"
done < file.txt
```

---

## (k) Манипуляции со строками

Ниже описаны все основные конструкции.

---

### **Получение значения**
- **`${var}`** — безопасный вариант использования переменной.

---

### **Длина строки**
- **`${#var}`** — количество символов.

---

### **Срезы**
- `${var:N}` — начиная с позиции N
- `${var:N:K}` — начиная с N, длина K

Пример:

```bash
var="abcdef"
echo ${var:2}    # cdef
echo ${var:2:3}  # cde
```

---

### **Значение по умолчанию**

- `${var:-default}` — использовать default, если var *пустая или не существует*
- `${var:=default}` — то же самое, но **ещё и присваивает** default

---

### **Удаление шаблонов**

- `${var#pattern}` — удалить *минимальное* совпадение слева
- `${var##pattern}` — удалить *максимальное* совпадение слева
- `${var%pattern}` — минимальное справа
- `${var%%pattern}` — максимальное справа

---

### **Замена подстроки**

- `${var/pat/str}` — заменить первое вхождение
- `${var//pat/str}` — заменить все

---

### **Изменение регистра**

- `${var^^}` — в верхний регистр
- `${var,,}` — в нижний регистр

---

## ### (l) Работа с целыми числами

### **Вопрос:** *Чем отличаются конструкции `((...))` и `$((...))`?*

**Ответ:**

| Конструкция | Назначение |
|------------|------------|
| `((...))` | Выполняет арифметику, возвращает код возврата, но ничего не выводит |
| `$((...))` | Возвращает результат как строку |

Пример:

```bash
((a=2+3))    # арифметика (код возврата 0)
echo $((2+3)) # печатает 5
```

---

## ### (m) Функции Bash

### **Вопрос:** *Как объявляются функции в Bash?*

Форматы:

```bash
function myfunc { ... }
myfunc() { ... }
```

### **Аргументы функции**
Используются переменные:

- `$1`, `$2`, `$3` — аргументы
- `$#` — количество аргументов
- `$@` — все аргументы (отдельные строки)
- `$*` — все аргументы (одной строкой)

---

### **Локальные переменные**

```bash
myfunc() {
  local x=10
}
```

`local` ограничивает область внутри функции.

---

### **Возврат кода**

```bash
return 3
```

Возвращает только *код возврата* (0–255), не строку.

---

## ### (n) Массивы

### **Создание массива**

```bash
arr=(a b c)
```

### **Получение элемента**

```bash
echo ${arr[0]}
```

### **Добавление элемента**

```bash
arr+=(d)
```

### **Перебор**

```bash
for x in "${arr[@]}"; do
  echo "$x"
done
```

---

## ### (o) Чтение из stdin и файлов

---

### **Команда `read`**

Основные опции:

| Опция | Значение |
|-------|----------|
| `-p` | выводит приглашение |
| `-r` | не интерпретировать `\` |
| `-a` | прочитать в массив |
| `-s` | скрыть ввод (например пароль) |

Пример:

```bash
read -p "Введите имя: " name
```

---

### **Чтение файла построчно**

```bash
while read -r line; do
  echo "Строка: $line"
done < file.txt
```

---

### **readarray**

```bash
readarray arr < file.txt
```

Создаёт массив, где каждый элемент — строка.

---

#  8. Процессы

---

##  (a) Основные понятия, связанные с процессами

**Вопрос:** *Что такое программа и процесс? Чем они различаются?*

**Ответ:**
- **Программа** — это просто файл на диске, содержащий инструкции.
- **Процесс** — это выполняющийся экземпляр программы с собственным состоянием.

Когда программа запускается, ядро создаёт **процесс**, выделяя ему:
- адресное пространство,
- регистры,
- стек,
- PID (идентификатор процесса),
- таблицу открытых файлов.

---

### **Родительский и дочерний процессы**

Новый процесс создаётся через системный вызов **fork()**:
- родитель получает PID дочернего процесса,
- ребёнок получает PID = 0 внутри себя.

Затем используется **exec()**, который заменяет код процесса новым (например, запускает программу `/bin/ls`).

---

### **Потоки**

Процессы могут содержать **несколько потоков**, разделяющих:
- память,
- файлы,
- переменные.

Но **у процессов память изолирована**, поэтому процессы тяжелее потоков.

---

### **Планировщик и квант времени**

Планировщик ядра распределяет процессорное время между процессами, назначая каждому **квант** (короткий интервал выполнения).

---

## (b) Просмотр информации о процессах

---

### **Команда `ps`**

Используется для отображения процессов.

Основные режимы:

- `ps aux` — показывает все процессы во всех сессиях.
    - `a` — процессы всех пользователей
    - `u` — формат “user-friendly”
    - `x` — процессы без терминала

- `ps -e` — все процессы
- `ps -f` — полный формат
- `ps -u username` — процессы конкретного пользователя
- `ps -p PID` — процесс по PID
- `ps -C имя` — поиск по имени команды
- `ps --ppid PID` — дочерние процессы

---

### **Основные поля в выводе `ps`:**

| Поле | Значение |
|------|----------|
| pid | идентификатор процесса |
| user | владелец |
| %cpu | процент загрузки CPU |
| %mem | использование RAM |
| rss | реальная RAM |
| vsz | виртуальная память |
| stat | состояние |
| time | время CPU |
| cmd | команда |

---

### **Команда `pstree`**

Показывает дерево процессов:
```
systemd─┬─sshd──bash──pstree
        └─NetworkManager
```

---

## ### (c) Идентификаторы процессов

- **PID** — уникальный ID процесса.
- **PPID** — ID родителя.

---

### **Как получить PID:**

- `echo $$` — PID текущего shell
- `$!` — PID последнего фонового процесса
- `$PPID` — PID родителя

---

## ### (d) Сигналы

**Сигнал** = программный “пинок” процессу.

---

### Основные сигналы:

| Сигнал | Значение |
|--------|----------|
| SIGTERM | корректное завершение |
| SIGINT | Ctrl‑C |
| SIGKILL | немедленное убийство |
| SIGSTOP | остановить |
| SIGCONT | продолжить |
| SIGHUP | закрытие терминала |
| SIGCHLD | процесс‑ребёнок завершился |

---

### Команда `kill`

```
kill -SIGTERM 1234
kill -9 1234   # SIGKILL
```

---

### `killall`, `pkill`

```
killall firefox
pkill -f pattern
```

---

## ### (e) Команда `trap`

Позволяет ловить сигналы.

Пример:

```bash
trap "echo SIGINT пойман" SIGINT
while true; do :; done
```

---

### Сигналы, которые нельзя поймать:

- SIGKILL
- SIGSTOP

---

### Ловля выхода:

```bash
trap "echo Завершение скрипта" EXIT
```

---

## ### (f) Группы процессов и сессии

- **PGID** — ID группы процессов.
- Сигналы можно посылать всей группе:

```
kill -TERM -1234
```

(минус означает “группа”, а не PID)

- **SID** — ID сессии.  
  Обычно один терминал = одна сессия.

---

## ### (g) Состояния процессов

| Состояние | Значение |
|-----------|----------|
| R | running / runnable |
| S | sleeping |
| D | uninterruptible sleep — нельзя убить даже SIGKILL |
| T | stopped |
| Z | zombie — процесс завершился, но родитель не забрал статус |

---

## ### (h) Управление заданиями

- Запуск в фоне:

```
command &
```

- Список задач: `jobs`
- Перевести в фон: `bg`
- Вернуть на передний план: `fg`

---

### Что происходит при:

- **Ctrl‑C** → SIGINT
- **Ctrl‑Z** → SIGTSTP
- **Закрытии терминала** → SIGHUP

---

## ### (i) Отсоединённый процесс

---

### **1. nohup**

```
nohup cmd &
```

Вывод сохраняется в `nohup.out`.

---

### **2. disown**

Отвязать от shell:

```
disown -a
```

---

### **3. setsid**

Запускает процесс в новой сессии:

```
setsid cmd
```

---

### **Демоны**

- не имеют терминала,
- работают в фоне постоянно.

---

## ### (j) Приоритеты процессов

---

### **nice**

Увеличить niceness:

```
nice -n 10 cmd
```

Значения nice: от `-20` до `19`.  
Меньше — важнее, больше — менее приоритетно.

---

### **renice**

Изменить существующий процесс:

```
renice -n 5 -p 1234
```

---

## ### (k) Мониторинг процессов (top)

`top` показывает:

- загрузку CPU,
- память,
- процессы.

### Основные параметры:

| Поле | Значение |
|------|----------|
| load average | средняя загрузка CPU |
| us | пользовательские процессы |
| sy | системные |
| id | простои |
| wa | ожидание диска |

И др.

---

## ### (l) /proc

Важные файлы:

| Файл | Значение |
|------|----------|
| cmdline | команда |
| environ | переменные |
| cwd | текущий каталог |
| exe | путь к исполняемому |
| maps | карта памяти |
| fd/ | открытые файлы |
| status | состояние |

---

# ## 9. systemd

---

## ### (a) Основы systemd

**systemd** — современная система инициализации Linux, управляющая:

- службами,
- точками монтирования,
- сокетами,
- таймерами.

**Юнит** — сущность systemd (service, timer, path, target…).

---

## ### (b) Команда `systemctl`

Основные:

```
systemctl start NAME
systemctl stop NAME
systemctl restart NAME
systemctl status NAME
systemctl enable NAME
systemctl disable NAME
```

Дополнительно:

```
systemctl daemon-reload
systemctl list-units
systemctl cat NAME
systemctl reload NAME
```

---

## ### (c) Юнит-файлы

Расположение:

- `/etc/systemd/system` — локальные (приоритет)
- `/usr/lib/systemd/system` — системные

---

### Структура юнит-файла

```
[Unit]
Description=
After=
Requires=

[Service]
Type=
ExecStart=
ExecStop=
Restart=
User=
Environment=

[Install]
WantedBy=
```

---

### Типы сервисов:

- `simple` — процесс запускается и работает
- `forking` — демон, который форкается
- `oneshot` — выполняется и завершается
- `notify` — сообщает systemd о готовности

---

## ### (d) Таймеры

Используются вместо cron.

### Основные директивы:

- `OnCalendar=`
- `OnBootSec=`
- `OnActiveSec=`
- `Persistent=`
- `RandomizedDelaySec=`

---

Пример таймера:

```
[Unit]
Description=Запуск сервиса

[Timer]
OnCalendar=*-*-* 12:00:00
Persistent=true

[Install]
WantedBy=timers.target
```

---

## ### (e) Path-юниты

Срабатывают при изменении файла.

Директивы:

- `PathExists=`
- `PathChanged=`

---

## ### (f) Журнал

```
journalctl -u service
journalctl -b
journalctl -f
journalctl --since "1 hour ago"
```

---



